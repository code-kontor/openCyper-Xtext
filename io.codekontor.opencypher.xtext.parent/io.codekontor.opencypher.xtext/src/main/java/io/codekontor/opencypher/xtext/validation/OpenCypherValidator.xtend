/*
 * openCypher Xtext - Slizaa Static Software Analysis Tools
 * Copyright Â© ${year} Code-Kontor GmbH and others (slizaa@codekontor.io)
 *
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License 2.0 which is available at
 * http://www.eclipse.org/legal/epl-2.0.
 *
 * SPDX-License-Identifier: EPL-2.0
 *
 * Contributors:
 *  Code-Kontor GmbH - initial API and implementation
 */
/*
 * generated by Xtext 2.10.0
 */
package io.codekontor.opencypher.xtext.validation

import java.util.regex.Pattern
import org.eclipse.xtext.EcoreUtil2
import org.eclipse.xtext.validation.Check
import io.codekontor.opencypher.xtext.openCypher.DecimalInteger
import io.codekontor.opencypher.xtext.openCypher.LegacyParameter
import io.codekontor.opencypher.xtext.openCypher.OpenCypherPackage
import io.codekontor.opencypher.xtext.openCypher.Parameter
import io.codekontor.opencypher.xtext.openCypher.RangeLiteral
import io.codekontor.opencypher.xtext.openCypher.Return
import io.codekontor.opencypher.xtext.openCypher.VersionNumber
import io.codekontor.opencypher.xtext.openCypher.Cypher
import com.google.inject.name.Named
import com.google.inject.Inject

/**
 * This class contains custom validation rules. 
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
class OpenCypherValidator extends AbstractOpenCypherValidator {

	/* - */
	static final Pattern VERSION_NUMBER_FORMAT = Pattern.compile("\\d*\\.\\d*");

	/* - */
	static final Pattern DECIMAL_INTEGER_FORMAT = Pattern.compile("[1..9]*\\d*");

	/* - */
	public static val INVALID_VERSION_NUMBER_FORMAT = 'invalidVersionNumber'

	/* - */
	public static val INVALID_DECIMAL_INTEGER_FORMAT = 'invalidDecimalInteger'
	
		/* - */
	public static val INVALID_STATEMENT_COUNT = 'invalidStatementCount'

	/* - */
	public static val RETURN_NOT_AT_THE_END = 'returnNotAtTheEnd'
	
	@Inject(optional=true)
	@Named("opencypher.allowMultipleStatements")
	private boolean allowMultipleStatements = false;
	
	@Check
	def checkCypherFormat(Cypher cypher) {
		
		if (allowMultipleStatements) {
			return
		}
		
		if (cypher.statements.size != 1) {
				error('There must be exactly one statement.',
				OpenCypherPackage.eINSTANCE.cypher_Statements, INVALID_STATEMENT_COUNT)
		}
	}

	@Check
	def checkLegacyParameterFormat(LegacyParameter legacyParameter) {
		// TODO check!
		// legacyParameter : '{' ws ( symbolicName | DecimalInteger ) ws '}' ;
	}

	@Check
	def checkParameterFormat(Parameter parameter) {
		// TODO check!
		// parameter : '$' ( symbolicName | DecimalInteger ) ;
	}

	@Check
	def checkRangeLiteralFormat(RangeLiteral rangeLiteral) {
		// TODO check!
		rangeLiteral.lower
		// TODO check!
		rangeLiteral.upper
	}

	@Check
	def checkDecimalIntegerFormat(DecimalInteger decimalInteger) {
		if (!DECIMAL_INTEGER_FORMAT.matcher(decimalInteger.value).matches()) {
			error('Version number must have the following format: (digit)+\'.\'(digit)+',
				OpenCypherPackage.eINSTANCE.decimalInteger_Value, INVALID_DECIMAL_INTEGER_FORMAT)
		}
	}

	@Check
	def checkVersionNumberFormat(VersionNumber versionNumber) {
		if (versionNumber.versionNumber !== null) {
			if (!VERSION_NUMBER_FORMAT.matcher(versionNumber.versionNumber).matches()) {
				error('Version number must have the following format: (digit)+\'.\'(digit)+',
					OpenCypherPackage.eINSTANCE.versionNumber_VersionNumber, INVALID_VERSION_NUMBER_FORMAT)
			}
		}
	}

	@Check
	def checkReturn(Return ret) {
		if (EcoreUtil2.getNextSibling(ret) !== null) {
			error('RETURN can only be used once at the end of the query', ret,
				OpenCypherPackage.eINSTANCE.return_Return, RETURN_NOT_AT_THE_END)
		}
	}
}
