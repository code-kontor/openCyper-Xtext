/*
 * generated by Xtext 2.10.0
 */
package org.slizaa.neo4j.opencypher.ui.outline

import org.eclipse.xtext.EcoreUtil2
import org.eclipse.xtext.nodemodel.util.NodeModelUtils
import org.eclipse.xtext.ui.editor.outline.IOutlineNode
import org.eclipse.xtext.ui.editor.outline.impl.DefaultOutlineTreeProvider
import org.eclipse.xtext.ui.editor.outline.impl.DocumentRootNode
import org.slizaa.neo4j.opencypher.openCypher.Cypher
import org.slizaa.neo4j.opencypher.openCypher.CombinedQuery
import org.slizaa.neo4j.opencypher.openCypher.SingleQuery
import org.slizaa.neo4j.opencypher.openCypher.Statement
import org.slizaa.neo4j.opencypher.openCypher.UpdatingClause
import org.slizaa.neo4j.opencypher.openCypher.ReadingClause
import org.slizaa.neo4j.opencypher.openCypher.Return

/**
 * Customization of the default outline structure.
 * 
 * See https://www.eclipse.org/Xtext/documentation/310_eclipse_support.html#outline
 */
class OpenCypherOutlineTreeProvider extends DefaultOutlineTreeProvider {

	def boolean _isLeaf(UpdatingClause clause) {
		return true;
	}

	def boolean _isLeaf(ReadingClause clause) {
		return true;
	}

	def boolean _isLeaf(Return r) {
		return true;
	}

	def void _createChildren(DocumentRootNode parentNode, Cypher cypher) {

		for (element : EcoreUtil2.getAllContentsOfType(cypher, Statement)) {

			if (element instanceof CombinedQuery) {
				val CombinedQuery combinedQuery = element as CombinedQuery;
				val SingleQuery singleQuery = combinedQuery.singleQuery;
// TODO			
//				createNode(parentNode, combinedQuery);
//				val IOutlineNode combinedQueryParent = NodeModelUtils.getNode(combinedQuery); //FIXME: getNode does not return IOutlineNode
//				createNode(combinedQueryParent, singleQuery);
//				val IOutlineNode singleQueryParent = NodeModelUtils.getNode(singleQuery); //FIXME: getNode does not return IOutlineNode
//				_addSingleQueryClauses(singleQueryParent, singleQuery);
//				for (_union : combinedQuery.union) {
//					createNode(combinedQueryParent, _union.singleQuery);
//					val IOutlineNode _unionParent = NodeModelUtils.getNode(_union.singleQuery); //FIXME: getNode does not return IOutlineNode
//					_addSingleQueryClauses(_unionParent, _union.singleQuery);
//				}
			} else if (element instanceof SingleQuery) {
				val SingleQuery singleQuery = element as SingleQuery;
				_addSingleQueryClauses(parentNode, singleQuery);
			} else {
				createNode(parentNode, element);
			}
		}
	}

	def void _addSingleQueryClauses(IOutlineNode parentNode, SingleQuery singleQuery) {
// TODO
//		for (clause : singleQuery.clauses) {
//			createNode(parentNode, clause);
//		}
	}
}
