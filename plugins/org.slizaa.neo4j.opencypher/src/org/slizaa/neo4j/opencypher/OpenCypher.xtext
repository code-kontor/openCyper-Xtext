grammar org.slizaa.neo4j.opencypher.OpenCypher hidden(WS, ML_COMMENT, SL_COMMENT)

import "http://www.eclipse.org/emf/2002/Ecore" as ecore
generate openCypher "http://www.slizaa.org/neo4j/opencypher/OpenCypher"

Cypher:
/*
 * oC_Cypher : SP? oC_QueryOptions oC_Statement ( SP? ';' )? SP? EOF ;
 */
	{Cypher} queryOptions=QueryOptions statement=Statement ';'?;

QueryOptions:
/*
 * oC_QueryOptions : ( oC_AnyCypherOption SP? )* ;
 * oC_AnyCypherOption : oC_CypherOption
 *                    | oC_Explain
 *                    | oC_Profile
 *                    ;
 * oC_Explain : EXPLAIN ;
 * oC_Profile : PROFILE ;
 */
	{AllOptions} (explain?='EXPLAIN'? & profile?='PROFILE'? & cypherOption+=CypherOption*);

CypherOption:
/*
 * oC_CypherOption : CYPHER ( SP oC_VersionNumber )? ( SP oC_ConfigurationOption )* ;
 */
	{CypherOption} 'CYPHER' (versionNumber=VersionNumber)? (configurationOption+=ConfigurationOption)*;

VersionNumber:
/*
 * oC_VersionNumber : RegularDecimalReal ;
 */
	versionNumber=Number;

ConfigurationOption:
/*
 * oC_ConfigurationOption : oC_SymbolicName SP? '=' SP? oC_SymbolicName ;
 */
	key=SYMBOLIC_NAME_X '=' value=SYMBOLIC_NAME_X;

Statement:
/*
 * oC_Statement : oC_Command
 *              | oC_Query
 *              ;
 */
	Command | Query;

Query:
/*
 * oC_Query : oC_RegularQuery
 *          | oC_StandaloneCall
 *          | oC_BulkImportQuery
 *          ;
 */
	RegularQuery | StandaloneCall | BulkImportQuery;

RegularQuery:
/*
 * oC_RegularQuery : oC_SingleQuery ( SP? oC_Union )* ;
 */
	SingleQuery ({CombinedQuery.singleQuery=current} (union+=Union)+)?;

BulkImportQuery:
/*
 * oC_BulkImportQuery : oC_PeriodicCommitHint SP? oC_LoadCSVQuery ;
 */
	periodicCommitHint=PeriodicCommitHint loadCSVQuery=LoadCSVQuery;

PeriodicCommitHint:
/*
 * oC_PeriodicCommitHint : USING SP PERIODIC SP COMMIT ( SP oC_IntegerLiteral )? ;
 */
	{PeriodicCommitHint} 'USING' 'PERIODIC' 'COMMIT' numberOfRowsPerCommit=DecimalInteger?;

LoadCSVQuery:
/*
 * oC_LoadCSVQuery : oC_LoadCSV oC_SingleQuery ;
 */
	loadCSV=LoadCSV singleQuery=SingleQuery;

Union:
/*
 * oC_Union : ( UNION SP ALL SP? oC_SingleQuery )
 *          | ( UNION SP? oC_SingleQuery )
 *          ;
 */
	('UNION' all?='ALL'? singleQuery=SingleQuery);

SingleQuery:
/*
 * oC_SingleQuery : oC_SinglePartQuery
 *                | oC_MultiPartQuery
 *                ;
 */
	SinglePartQuery | MultiPartQuery;

SinglePartQuery:
/*
 * oC_SinglePartQuery : oC_ReadOnlyEnd
 *                    | oC_ReadUpdateEnd
 *                    | oC_UpdatingEnd
 *                    ;
 */
	ReadOnlyEnd | ReadUpdateEnd | UpdatingEnd;

ReadOnlyEnd:
/*
 * oC_ReadOnlyEnd : oC_ReadPart oC_Return ;
 */
	readPart=ReadPart return=Return;

ReadUpdateEnd:
/*
 * oC_ReadUpdateEnd : oC_ReadingClause ( SP? oC_ReadingClause )* ( SP? oC_UpdatingClause )+ ( SP? oC_Return )? ;
 */
	(readingClauses+=ReadingClause)+ (updatingClauses+=UpdatingClause)+ return?=Return;

UpdatingEnd:
/*
 * oC_UpdatingEnd : oC_UpdatingStartClause ( SP? oC_UpdatingClause )* ( SP? oC_Return )? ;
 */
	updatingStartClause=UpdatingStartClause (updatingClauses+=UpdatingClause)* return?=Return;

MultiPartQuery:
/*
 * oC_MultiPartQuery : ( oC_ReadPart | ( oC_UpdatingStartClause SP? oC_UpdatingPart ) ) oC_With SP? ( oC_ReadPart oC_UpdatingPart oC_With SP? )* oC_SinglePartQuery ;
 * 
 * Comment: withPart instead of with as 'with' is a key word of xtext
 * Comment: introduced MultiPartSubQuery to encapsulate the repeating group
 */
	(readPart=ReadPart | updatingStartClause=UpdatingStartClause updatingPart=UpdatingPart) withPart=With
	(subQueries+=MultiPartSubQuery)* singlePartQuery=SinglePartQuery;

MultiPartSubQuery:
/*
 * readPart updatingPart with
 */
	readPart=ReadPart updatingPart=UpdatingPart withPart=With;

ReadPart:
/*
 * oC_ReadPart : ( oC_ReadingClause SP? )* 
 */
	{ReadPart} readingClause+=ReadingClause*;

UpdatingPart:
/*
 * oC_UpdatingPart : ( oC_UpdatingClause SP? )* ;
 */
	{UpdatingPart} updatingClauses+=UpdatingClause*;

UpdatingStartClause:
/*
 * oC_UpdatingStartClause : oC_Create
 *                        | oC_Merge
 *                        | oC_CreateUnique
 *                        | oC_Foreach
 *                        ;
 */
	Create | Merge | CreateUnique | Foreach;

UpdatingClause:
/*
 * oC_UpdatingClause : oC_Create
 *                   | oC_Merge
 *                   | oC_CreateUnique
 *                   | oC_Foreach
 *                   | oC_Delete
 *                   | oC_Set
 *                   | oC_Remove
 *                   ;
 */
	Create | Merge | CreateUnique | Foreach | Delete | Set | Remove;

ReadingClause:
/*
 * oC_ReadingClause : oC_LoadCSV
 *                  | oC_Start
 *                  | oC_Match
 *                  | oC_Unwind
 *                  | oC_InQueryCall
 *                  ;
 */
	LoadCSV | Start | Match | Unwind | InQueryCall;

Command:
/*
 * oC_Command : oC_CreateIndex
 *            | oC_DropIndex
 *            | oC_CreateUniqueConstraint
 *            | oC_DropUniqueConstraint
 *            | oC_CreateNodePropertyExistenceConstraint
 *            | oC_DropNodePropertyExistenceConstraint
 *            | oC_CreateRelationshipPropertyExistenceConstraint
 *            | oC_DropRelationshipPropertyExistenceConstraint
 *            ;
 */
	CreateIndex | DropIndex | CreateUniqueConstraint | DropUniqueConstraint | CreateNodePropertyExistenceConstraint |
	DropNodePropertyExistenceConstraint | CreateRelationshipPropertyExistenceConstraint |
	DropRelationshipPropertyExistenceConstraint;

CreateUniqueConstraint:
/*
 * oC_CreateUniqueConstraint : CREATE SP oC_UniqueConstraint ;
 */
	'CREATE' UniqueConstraint;

CreateNodePropertyExistenceConstraint:
/*
 * oC_CreateNodePropertyExistenceConstraint : CREATE SP oC_NodePropertyExistenceConstraint ;
 */
	'CREATE' NodePropertyExistenceConstraint;

CreateRelationshipPropertyExistenceConstraint:
/*
 * oC_CreateRelationshipPropertyExistenceConstraint : CREATE SP oC_RelationshipPropertyExistenceConstraint ;
 */
	'CREATE' RelationshipPropertyExistenceConstraint;

CreateIndex:
/*
 * oC_CreateIndex : CREATE SP oC_Index ;
 */
	'CREATE' index=Index;

DropUniqueConstraint:
/*
 * oC_DropUniqueConstraint : DROP SP oC_UniqueConstraint ;
 */
	'DROP' uniqueConstraint=UniqueConstraint;
	
DropNodePropertyExistenceConstraint:
/*
 * oC_DropNodePropertyExistenceConstraint : DROP SP oC_NodePropertyExistenceConstraint ;
 */
	'DROP' nodePropertyExistenceConstraint=NodePropertyExistenceConstraint;

DropRelationshipPropertyExistenceConstraint:
/*
 * oC_DropRelationshipPropertyExistenceConstraint : DROP SP oC_RelationshipPropertyExistenceConstraint ;
 */
	'DROP' relationshipPropertyExistenceConstraint=RelationshipPropertyExistenceConstraint;

DropIndex:
/*
 * oC_DropIndex : DROP SP oC_Index ;
 */
	'DROP' index=Index;

Index:
/*
 * oC_Index : INDEX SP ON SP? oC_NodeLabel '(' oC_PropertyKeyName ')' ;
 */
	'INDEX' 'ON' nodeLabel=NodeLabel '(' propertyKeyName=PropertyKeyName ')';
	
UniqueConstraint:
/*
 * oC_UniqueConstraint : CONSTRAINT SP ON SP? '(' oC_Variable oC_NodeLabel ')' SP? ASSERT SP oC_PropertyExpression SP IS SP UNIQUE ;
 */
	'CONSTRAINT' 'ON' '(' variable=VariableDeclaration nodeLabel=NodeLabel ')' 'ASSERT'
	propertyExpression=PropertyExpression 'IS'
	'UNIQUE';

NodePropertyExistenceConstraint:
/*
 * oC_NodePropertyExistenceConstraint : CONSTRAINT SP ON SP? '(' oC_Variable oC_NodeLabel ')' SP? ASSERT SP EXISTS SP? '(' oC_PropertyExpression ')' ;
 */
	'CONSTRAINT' 'ON' '(' variable=VariableDeclaration nodeLabel=NodeLabel ')' 'ASSERT' 'EXISTS' '('
	propertyExpression=PropertyExpression ')';		

RelationshipPropertyExistenceConstraint:
/*
 * oC_RelationshipPropertyExistenceConstraint : CONSTRAINT SP ON SP? oC_RelationshipPatternSyntax SP? ASSERT SP EXISTS SP? '(' oC_PropertyExpression ')' ;
 */
	'CONSTRAINT' 'ON' relationshipPattern=RelationshipPatternSyntax 'ASSERT' 'EXISTS' '('
	propertyExpression=PropertyExpression ')';

RelationshipPatternSyntax:
/*
 * oC_RelationshipPatternSyntax : ( '(' SP? ')' oC_Dash '[' oC_Variable oC_RelType ']' oC_Dash '(' SP? ')' )
 *                              | ( '(' SP? ')' oC_Dash '[' oC_Variable oC_RelType ']' oC_Dash oC_RightArrowHead '(' SP? ')' )
 *                              | ( '(' SP? ')' oC_LeftArrowHead oC_Dash '[' oC_Variable oC_RelType ']' oC_Dash '(' SP? ')' )
 *                              ;
 */
	('(' ')' incoming?=LeftArrowHead? Dash '[' variable=VariableDeclaration relType=RelType ']' Dash
	outgoing?=RightArrowHead? '(' ')');

LoadCSV:
/*
 * loadCSV : LOAD sp CSV sp ( WITH sp HEADERS sp )? FROM sp expression sp AS sp variable sp ( FIELDTERMINATOR sp StringLiteral )? ;
 * 
 * Comment: For simplicity we split up the antlr clause in xtext clauses 'LoadCSV' and 'LoadCSVWithHeaders'
 */
	{LoadCSV} 'LOAD' 'CSV' withHeaders?=LoadCSVWithHeaders? 'FROM' expression=Expression 'AS'
	variable=VariableDeclaration
	('FIELDTERMINATOR' fieldterminator=STRING_LITERAL)?;

LoadCSVWithHeaders:
	'WITH' 'HEADERS';

Match:
/*
 * oC_Match : ( OPTIONAL SP )? MATCH SP? oC_Pattern ( oC_Hint )* ( SP? oC_Where )? ;
 */
	optional?='OPTIONAL'? 'MATCH' pattern=Pattern (hints+=Hint)* where=Where?;

Unwind:
/*
 * oC_Unwind : UNWIND SP? oC_Expression SP AS SP oC_Variable ;
 */
	'UNWIND' expression=Expression 'AS' variable=VariableDeclaration;

Merge:
/*
 * oC_Merge : MERGE SP? oC_PatternPart ( SP oC_MergeAction )* ;
 */
	'MERGE' patternPart=PatternPart (mergeActions+=MergeAction)*;

MergeAction:
/*
 * oC_MergeAction : ( ON SP MATCH SP oC_Set )
 *                | ( ON SP CREATE SP oC_Set )
 *                ;
 */
	'ON' action=('MATCH' | 'CREATE') set=Set;
	
Create:
/*
 * oC_Create : CREATE SP? oC_Pattern ;
 */
	'CREATE' pattern=Pattern;

CreateUnique:
/*
 * oC_CreateUnique : CREATE SP UNIQUE SP? oC_Pattern ;
 */	
	'CREATE' uniqueContraint=UniqueConstraint;
	
Set:
/*
 * oC_Set : SET SP? oC_SetItem ( ',' oC_SetItem )* ;
 */
	'SET' setItems+=SetItem (',' setItems+=SetItem)*;

SetItem:
/*
 * oC_SetItem : ( oC_PropertyExpression SP? '=' SP? oC_Expression )
 *            | ( oC_Variable SP? '=' SP? oC_Expression )
 *            | ( oC_Variable SP? '+=' SP? oC_Expression )
 *            | ( oC_Variable SP? oC_NodeLabels )
 *            ;
 */
	(propertyExpression=PropertyExpression '=' expression=Expression) | (variable=VariableDeclaration '='
	expression=Expression) | (variable=VariableDeclaration '+=' expression=Expression) | (variable=VariableDeclaration
	nodeLabels=NodeLabels);	

Delete:
/*
 * oC_Delete : ( DETACH SP )? DELETE SP? oC_Expression ( SP? ',' SP? oC_Expression )* ;
 */
	(detach?='DETACH')? 'DELETE' expressions+=Expression (',' expressions+=Expression)*;

Remove:
/*
 * oC_Remove : REMOVE SP oC_RemoveItem ( SP? ',' SP? oC_RemoveItem )* ;
 */
	'REMOVE' removeItems+=RemoveItem (',' removeItems+=RemoveItem)*;

RemoveItem:
/*
 * oC_RemoveItem : ( oC_Variable oC_NodeLabels )
 *               | oC_PropertyExpression
 *               ;
 */
	(variable=VariableDeclaration nodeLabels=NodeLabels) | PropertyExpression;

Foreach:
/*
 * oC_Foreach : FOREACH SP? '(' SP? oC_Variable SP IN SP oC_Expression SP? '|' ( SP oC_UpdatingClause )+ SP? ')' ;
 */
	'FOREACH' '(' variable=VariableDeclaration 'IN' expression=Expression '|' (clauses+=Clause)+ ')';

InQueryCall:
/*
 * oC_InQueryCall : CALL SP oC_ExplicitProcedureInvocation ( SP? YIELD SP oC_YieldItems )? ;
 */
	'CALL' invocation=ExplicitProcedureInvocation ('YIELD' yieldItems=YieldItems)?;

StandaloneCall:
/*
 * oC_StandaloneCall : CALL SP ( oC_ExplicitProcedureInvocation | oC_ImplicitProcedureInvocation ) ( SP YIELD SP oC_YieldItems )? ;
 */
	'CALL' invocation=(ExplicitProcedureInvocation | ImplicitProcedureInvocation) ('YIELD' yieldItems=YieldItems)?;

YieldItems:
/*
 * oC_YieldItems : ( oC_YieldItem ( SP? ',' SP? oC_YieldItem )* )
 *               | '-'
 *               ;
 */
	{YieldItems} ((items+=YieldItem (',' items+=YieldItem)*) | '-');

YieldItem:
/*
 * oC_YieldItem : ( oC_ProcedureResultField SP AS SP )? oC_Variable ;
 */
	(field=ProcedureResultField 'AS')? variable=VariableDeclaration;

With:
/*
 * oC_With : WITH ( SP? DISTINCT )? SP oC_ReturnBody ( SP? oC_Where )? ;
 */
	'WITH' distint?='DISTINCT'? returnBody=ReturnBody where=Where?;

Return:
/*
 * oC_Return : RETURN ( SP? DISTINCT )? SP oC_ReturnBody ;
 */
	(return='RETURN' distinct?='DISTINCT'? body=ReturnBody);

ReturnBody:
/*
 * oC_ReturnBody : oC_ReturnItems ( SP oC_Order )? ( SP oC_Skip )? ( SP oC_Limit )? ;
 */
	returnItems=ReturnItems (order=Order)? (skip=Skip)? (limit=Limit)?;

ReturnItems:
/*
 * oC_ReturnItems : ( '*' ( SP? ',' SP? oC_ReturnItem )* )
 *                | ( oC_ReturnItem ( SP? ',' SP? oC_ReturnItem )* )
 *                ;
 */
	{ReturnItems} (all='*' (',' items+=ReturnItem)*) | (items+=ReturnItem (',' items+=ReturnItem)*);

ReturnItem:
/*
 * oC_ReturnItem : ( oC_Expression SP AS SP oC_Variable )
 *               | oC_Expression
 *               ;
 */
	expression=Expression ('AS' alias=VariableDeclaration)?;

Order:
/*
 * oC_Order : ORDER SP BY SP oC_SortItem ( ',' SP? oC_SortItem )* ;
 */
	'ORDER' 'BY' orderBy+=SortItem (',' orderBy+=SortItem)*;

Skip:
/*
 * oC_Skip : L_SKIP SP oC_Expression ;
 */
	'SKIP' skip=Expression;

Limit:
/*
 * oC_Limit : LIMIT SP oC_Expression ;
 */
	'LIMIT' limit=Expression;

SortItem:
/*
 * oC_SortItem : oC_Expression ( SP? ( ASCENDING | ASC | DESCENDING | DESC ) )? ;
 */
	(expression=Expression sort=('DESCENDING' | 'DESC' | 'ASCENDING' | 'ASC')?);

Hint hidden():
/*
 * oC_Hint : SP? ( ( USING SP INDEX SP oC_Variable oC_NodeLabel '(' oC_PropertyKeyName ')' ) | ( USING SP JOIN SP ON SP oC_Variable ( SP? ',' SP? oC_Variable )* ) | ( USING SP SCAN SP oC_Variable oC_NodeLabel ) ) ;
 */
	{IndexHint} 'USING' WS 'INDEX' WS variable=VariableDeclaration nodeLabel=NodeLabel WS '('
	propertyKeyName=PropertyKeyName ')' | {JoinHint} ('USING' WS 'JOIN' WS 'ON' variables+=VariableDeclaration (','
	variables+=VariableDeclaration)*) | {ScanHint} ('USING' WS 'SCAN' WS variable=VariableDeclaration
	nodeLabel=NodeLabel);

Start:
/*
 * oC_Start : START SP oC_StartPoint ( SP? ',' SP? oC_StartPoint )* oC_Where? ;
 */
	'START' startPoint+=StartPoint (',' startPoint+=StartPoint)* where=Where?;

StartPoint:
/*
 * oC_StartPoint : oC_Variable SP? '=' SP? oC_Lookup ;
 */
	variable=VariableDeclaration '=' lookup=Lookup;

Lookup:
/*
 * oC_Lookup : oC_NodeLookup
 *           | oC_RelationshipLookup
 *           ;
 */
	NodeLookup | RelationshipLookup;

NodeLookup:
/*
 * oC_NodeLookup : NODE SP? ( oC_IdentifiedIndexLookup | oC_IndexQuery | oC_IdLookup ) ;
 */
	'NODE' (IdentifiedIndexLookup | IndexQuery | IdLookup);

RelationshipLookup:
/*
 * oC_RelationshipLookup : ( RELATIONSHIP | REL ) ( oC_IdentifiedIndexLookup | oC_IndexQuery | oC_IdLookup ) ;
 */
	('RELATIONSHIP' | 'REL') (IdentifiedIndexLookup | IndexQuery | IdLookup);

IdentifiedIndexLookup:
/*
 * oC_IdentifiedIndexLookup : ':' oC_SymbolicName '(' oC_SymbolicName '=' ( StringLiteral | oC_LegacyParameter ) ')' ;
 */
	':' indexName=SYMBOLIC_NAME_X '(' key=SYMBOLIC_NAME_X '=' (value=STRING_LITERAL | legacyParameter=LegacyParameter)
	')';

IndexQuery:
/*
 * oC_IndexQuery : ':' oC_SymbolicName '(' ( StringLiteral | oC_LegacyParameter ) ')' ;
 */
	':' indexName=SYMBOLIC_NAME_X '(' (query=STRING_LITERAL | parameter=Parameter) ')';

IdLookup:
/*
 * oC_IdLookup : '(' ( oC_LiteralIds | oC_LegacyParameter | '*' ) ')' ;
 */
	'(' (ids=LiteralIds | legacyParameter=Parameter | wildcard='*') ')';

LiteralIds:
/*
 * oC_LiteralIds : oC_IntegerLiteral ( SP? ',' SP? oC_IntegerLiteral )* ;
 */
	ids+=DecimalInteger (',' ids+=DecimalInteger)*;

Where:
/*
 * oC_Where : WHERE SP oC_Expression ;
 */
	'WHERE' expression=Expression;

Pattern:
/*
 * oC_Pattern : oC_PatternPart ( SP? ',' SP? oC_PatternPart )* ;
 */
	patterns+=PatternPart (',' patterns+=PatternPart)*;

PatternPart:
/*
 * oC_PatternPart : ( oC_Variable SP? '=' SP? oC_AnonymousPatternPart )
 *                | oC_AnonymousPatternPart
 *                ;
 */
	(var=VariableDeclaration '=' part=AnonymousPatternPart) | AnonymousPatternPart;

AnonymousPatternPart:
/*
 * oC_AnonymousPatternPart : oC_ShortestPathPattern
 *                         | oC_PatternElement
 *                         ;
 */
	ShortestPathPattern | PatternElement;

ShortestPathPattern:
/*
 * oC_ShortestPathPattern : ( SHORTESTPATH '(' oC_PatternElement ')' )
 *                        | ( ALLSHORTESTPATHS '(' oC_PatternElement ')' )
 *                        ;
 */
	{ShortestPath} 'SHORTESTPATH' '(' patternElement=PatternElement ')' | {AllShortestPaths} 'ALLSHORTESTPATHS' '('
	patternElement=PatternElement ')';

PatternElement:
/*
 * oC_PatternElement : ( oC_NodePattern ( SP? oC_PatternElementChain )* )
 *                   | ( '(' oC_PatternElement ')' )
 *                   ;
 */
	(nodepattern=NodePattern (chain+=PatternElementChain)*) | '(' PatternElement ')';

NodePattern:
/*
 * oC_NodePattern : '(' SP? ( oC_Variable SP? )? ( oC_NodeLabels SP? )? ( oC_Properties SP? )? ')' ;
 */
	{NodePattern} '(' variable=VariableDeclaration? nodeLabels=NodeLabels? properties=Properties? ')';

PatternElementChain:
/*
 * oC_PatternElementChain : oC_RelationshipPattern SP? oC_NodePattern ;
 */
	relationshipPattern=RelationshipPattern nodePattern=NodePattern;

RelationshipPattern:
/*
 * oC_RelationshipPattern : ( oC_LeftArrowHead SP? oC_Dash SP? oC_RelationshipDetail? SP? oC_Dash SP? oC_RightArrowHead )
 *                        | ( oC_LeftArrowHead SP? oC_Dash SP? oC_RelationshipDetail? SP? oC_Dash )
 *                        | ( oC_Dash SP? oC_RelationshipDetail? SP? oC_Dash SP? oC_RightArrowHead )
 *                        | ( oC_Dash SP? oC_RelationshipDetail? SP? oC_Dash )
 *                        ;
 */
	{RelationshipPattern} (incoming?=LeftArrowHead? Dash detail=RelationshipDetail? Dash outgoing?=RightArrowHead?);

RelationshipDetail:
/*
 * oC_RelationshipDetail : '[' SP? ( oC_Variable SP? )? ( oC_RelationshipTypes SP? )? oC_RangeLiteral? ( oC_Properties SP? )? ']' ;
 */
	{RelationshipDetail} '[' variable=VariableDeclaration? optional?='?'? types=RelationshipTypes? (range=RangeLiteral)?
	properties=Properties? ']';

Properties:
/*
 * oC_Properties : oC_MapLiteral
 *               | oC_Parameter
 *               | oC_LegacyParameter
 *               ;
 */
	MapLiteral | Parameter | LegacyParameter;

RelType:
/*
 * oC_RelType : ':' SP? oC_RelTypeName ;
 */
	':' RelTypeName;

RelationshipTypes:
/*
 * oC_RelationshipTypes : ':' SP? oC_RelTypeName ( SP? '|' ':'? SP? oC_RelTypeName )* ;
 */
	':' relTypeName+=RelTypeName ('|' ':'? relTypeName+=RelTypeName)*;

NodeLabels:
/*
 * oC_NodeLabels : oC_NodeLabel ( SP? oC_NodeLabel )* ;
 */
	nodeLabels+=NodeLabel (nodeLabels+=NodeLabel)*;

NodeLabel:
/*
 * oC_NodeLabel : ':' SP? oC_LabelName ;
 */
	':' labelName=LabelName;

RangeLiteral:
/*
 * oC_RangeLiteral : '*' SP? ( oC_IntegerLiteral SP? )? ( '..' SP? ( oC_IntegerLiteral SP? )? )? ;
 * 
 * Comment: Format of IntegerLiteral is checked via 
 * org.slizaa.neo4j.opencypher.validation.OpenCypherValidator.checkRangeLiteralFormat(RangeLiteral)
 */
	{RangeLiteral} '*' (lower=Number? ('..' upper=Number?)?)?;

LabelName:
/*
 * oC_LabelName : oC_SchemaName ;
 */
 // TODO
	SYMBOLIC_NAME_X;

RelTypeName:
/*
 * oC_RelTypeName : oC_SchemaName ;
 */
  // TODO
	SYMBOLIC_NAME_X;

Expression:
/*
 * oC_Expression : oC_OrExpression ;
 */
	OrExpression;

OrExpression returns Expression:
/*
 * oC_OrExpression : oC_XorExpression ( SP OR SP oC_XorExpression )* ;
 */
	XorExpression ({OrExpression.left=current} operator='OR' right=XorExpression)*;

XorExpression returns Expression:
/*
 * oC_XorExpression : oC_AndExpression ( SP XOR SP oC_AndExpression )* ;
 */
	AndExpression ({ExpressionXor.left=current} operator='XOR' right=AndExpression)*;

AndExpression returns Expression:
/*
 * oC_AndExpression : oC_NotExpression ( SP AND SP oC_NotExpression )* ;
 */
	NotExpression ({ExpressionAnd.left=current} operator='AND' right=NotExpression)*;

NotExpression returns Expression:
/*
 * oC_NotExpression : ( NOT SP? )* oC_ComparisonExpression ;
 * 
 * Comment: Clause is modeled on the former antlr clause 'expression9 : ( sp NOT sp expression9 ) | expression8;'
 * We should eventually adjust this...
 */
//TODO
	({ExpressionNot} operator='NOT' left=NotExpression) | ComparisonExpression;

ComparisonExpression returns Expression:
/*
 * oC_ComparisonExpression : oC_AddOrSubtractExpression ( SP? oC_PartialComparisonExpression )* ;
 * 
 * oC_PartialComparisonExpression : ( '=' SP? oC_AddOrSubtractExpression )
 *                                | ( '<>' SP? oC_AddOrSubtractExpression )
 *                                | ( '<' SP? oC_AddOrSubtractExpression )
 *                                | ( '>' SP? oC_AddOrSubtractExpression )
 *                                | ( '<=' SP? oC_AddOrSubtractExpression )
 *                                | ( '>=' SP? oC_AddOrSubtractExpression )
 *                                ;
 * 
 * Comment: combined clause for 'oC_ComparisonExpression' and 'oC_PartialComparisonExpression'
 */
	AddOrSubtractExpression ({ExpressionComparison.left=current} operator=('=' | '<>' | '<' | '>' | '<=' | '>=')
	right=AddOrSubtractExpression)*;

AddOrSubtractExpression returns Expression:
/*
 * oC_AddOrSubtractExpression : oC_MultiplyDivideModuloExpression ( ( SP? '+' SP? oC_MultiplyDivideModuloExpression ) | ( SP? '-' SP? oC_MultiplyDivideModuloExpression ) )* ;
 */
	MultiplyDivideModuloExpression ({ExpressionPlusMinus.left=current} operator=('+' | '-') right=MultiplyDivideModuloExpression)*;

MultiplyDivideModuloExpression returns Expression:
/*
 * oC_MultiplyDivideModuloExpression : oC_PowerOfExpression ( ( SP? '*' SP? oC_PowerOfExpression ) | ( SP? '/' SP? oC_PowerOfExpression ) | ( SP? '%' SP? oC_PowerOfExpression ) )* ;
 */
	PowerOfExpression ({ExpressionMulDiv.left=current} operator=('*' | '/' | '%') right=PowerOfExpression)*;

PowerOfExpression returns Expression:
/*
 * oC_PowerOfExpression : oC_UnaryAddOrSubtractExpression ( SP? '^' SP? oC_UnaryAddOrSubtractExpression )* ;
 */
	UnaryAddOrSubtractExpression ({ExpressionPower.left=current} operator='^' right=UnaryAddOrSubtractExpression)*;

UnaryAddOrSubtractExpression returns Expression:
/*
 * oC_UnaryAddOrSubtractExpression : ( ( '+' | '-' ) SP? )* oC_StringListNullOperatorExpression ;
 * 
 * Comment: In order to restrict our model for a single operator at a time, clause is modeled after a rewritten form of the antlr clause 'expression4 : expression3 | ( ( '+' | '-' ) ws ) expression4;'
 */
	Expression3 | {ExpressionUnaryPlusMinus} operator=('+' | '-') left=UnaryAddOrSubtractExpression;



/******* GW 2018-01-29: PROCEED HERE *******/

Expression3 returns Expression:
/*
 * expression3 : expression2 ( ( ws '[' expression ']' ) | ( ws '[' expression? '..' expression? ']' ) | ( ( ( ws '=~' ) | ( sp IN ) | ( sp STARTS sp WITH ) | ( sp ENDS sp WITH ) | ( sp CONTAINS ) ) ws expression2 ) | ( sp IS sp NULL ) | ( sp IS sp NOT sp NULL ) )* ;
 */
	ExpressionNodeLabelsAndPropertyLookup (({IndexExpression.left=current} '[' expression=Expression ('..'
	upper=Expression)? ']') | ({RegExpMatchingExpression.left=current} '=~' right=ExpressionNodeLabelsAndPropertyLookup)
	| ({InCollectionExpression.left=current} 'IN' right=ExpressionNodeLabelsAndPropertyLookup) |
	({StartsWithExpression.left=current} 'STARTS' 'WITH' right=ExpressionNodeLabelsAndPropertyLookup) |
	({EndsWithExpression.left=current} 'ENDS' 'WITH' right=ExpressionNodeLabelsAndPropertyLookup) |
	({ContainsExpression.left=current} 'CONTAINS' right=ExpressionNodeLabelsAndPropertyLookup) |
	({IsNullExpression.left=current} 'IS' 'NULL') | ({IsNotNullExpression.left=current} 'IS' 'NOT' 'NULL'))*;

ExpressionNodeLabelsAndPropertyLookup returns Expression:
/*
 * expression2 : atom ( propertyLookup | nodeLabels )* ;
 */
	Atom ({ExpressionNodeLabelsAndPropertyLookup.left=current} propertyLookups+=PropertyLookup |
	nodeLabelList+=NodeLabel)*;

/* Expression1 */
Atom returns Expression:
/*
 * atom : numberLiteral
 *      | StringLiteral
 *      | parameter
 *      | legacyParameter
 *      | TRUE
 *      | FALSE
 *      | NULL
 *      | caseExpression
 *      | ( COUNT '(' '*' ')' )
 *      | mapLiteral
 *      | listComprehension
 *      | patternComprehension
 *      | ( '[' ws expression ws ( ',' ws expression ws )* ']' )
 *      | ( FILTER ws '(' ws filterExpression ws ')' )
 *      | ( EXTRACT ws '(' ws filterExpression ws ( ws '|' expression )? ')' )
 *      | reduce
 *      | ( ALL ws '(' ws filterExpression ws ')' )
 *      | ( ANY ws '(' ws filterExpression ws ')' )
 *      | ( NONE ws '(' ws filterExpression ws ')' )
 *      | ( SINGLE ws '(' ws filterExpression ws ')' )
 *      | shortestPathPattern
 *      | relationshipsPattern
 *      | parenthesizedExpression
 *      | functionInvocation
 *      | variable
 *      ;
 */
	{NumberConstant} value=Number | {StringConstant} value=STRING_LITERAL | Parameter | LegacyParameter | {BoolConstant}
	value=('TRUE' | 'FALSE') | {NullConstant} 'NULL' | CaseExpression | {Count} 'COUNT' '(' '*' ')' | MapLiteral |
	ListComprehension | PatternComprehension | {ExpressionList} ('[' (expressions+=Expression (','
	expressions+=Expression)*)? ']') | {Extract} 'EXTRACT' '(' filterExpression=FilterExpression ('|'
	expression=Expression)? ')' | Reduce | {Filter} 'FILTER' '(' filterExpression=FilterExpression ')' | {All} 'ALL' '('
	filterExpression=FilterExpression ')' | {Any} 'ANY' '(' filterExpression=FilterExpression ')' | {None} 'NONE' '('
	filterExpression=FilterExpression ')' | {Single} 'SINGLE' '(' filterExpression=FilterExpression ')' |
	ShortestPathPattern | RelationshipsPattern | ParenthesizedExpression | FunctionInvocation | {VariableRef}
	variableRef=[VariableDeclaration|SYMBOLIC_NAME_X];

Reduce:
/*
 * reduce : REDUCE ws '(' variable '=' expression ',' idInColl '|' expression ')' ;
 */
	'REDUCE' '(' accumulator=VariableDeclaration '=' accumulatorExpression=Expression ',' idInColl=IdInColl '|'
	expression=Expression ')';

ParenthesizedExpression:
/*
 * parenthesizedExpression : '(' ws expression ws ')' ;
 */
	'(' expression=Expression ')';

RelationshipsPattern:
/*
 * relationshipsPattern : nodePattern ( ws patternElementChain )+ ;
 */
	nodePattern=NodePattern (chain+=PatternElementChain)+;

FilterExpression:
/*
 * filterExpression : idInColl ( ws where )? ;
 */
	idInColl=IdInColl (where=Where)?;





Clause:
/*
 * clause : loadCSV
 *        | start
 *        | match
 *        | unwind
 *        | merge
 *        | create
 *        | createUnique
 *        | set
 *        | delete
 *        | remove
 *        | foreach
 *        | with
 *        | return
 *        ;
 * 
 * Comment: We handle 'createUnique' within the 'create' clause
 */
	LoadCSV | Start | Match | Unwind | Merge | Create | Set | Delete | Remove | Foreach | With | Return | InQueryCall;



IdInColl:
/*
 * idInColl : variable sp IN sp expression ;
 */
	variable=VariableDeclaration 'IN' expression=Expression;

FunctionInvocation:
/*
 * functionInvocation : functionName ws '(' ws DISTINCT? ( expression ( ',' ws expression )* )? ws ')' ;
 */
	functionName=FunctionName '(' distinct?='DISTINCT'? (parameter+=Expression (',' parameter+=Expression)*)? ')';

FunctionName:
/*
 * functionName : symbolicName ;
 */
	SYMBOLIC_NAME_X;

ExplicitProcedureInvocation:
/*
 * ExplicitProcedureInvocation : ProcedureName '(' ( Expression ( ',' Expression )* )? ')' ;
 */
	procedureName=ProcedureName '(' (parameter+=Expression (',' parameter+=Expression)*)? ')';

ProcedureResultField:
/*
 * ProcedureResultField : SymbolicName ;
 */
	SYMBOLIC_NAME_X;

ImplicitProcedureInvocation:
/*
 * ImplicitProcedureInvocation : ProcedureName ;
 */
	ProcedureName;

ProcedureName:
/*
 * ProcedureName : Namespace SymbolicName ;
 */
	namespace=Namespace name=SYMBOLIC_NAME_X;

Namespace:
/**
 * Namespace : ( SymbolicName '.' )* ;
 */
	(SYMBOLIC_NAME_X '.')*;

ListComprehension:
/*
 * listComprehension : '[' filterExpression ( ws '|' expression )? ']' ;
 */
	'[' filterExpression=FilterExpression ('|' expression=Expression)? ']';

PatternComprehension:
/*
 * patternComprehension : '['  ( variable '=' )? relationshipsPattern ( WHERE expression )? '|' expression ']' ;
 */
	'[' (pathVariable=VariableDeclaration '=')? pattern=RelationshipsPattern (where=Where)? '|' expression=Expression
	']';

PropertyLookup:
/*
 * propertyLookup : ws '.' ws ( ( propertyKeyName ( '?' | '!' ) ) | propertyKeyName ) ;
 */
	'.' (propertyKeyName=PropertyKeyName propertyOperator=('?' | '!') | propertyKeyName=PropertyKeyName);

CaseExpression:
/*
 * caseExpression : ( ( CASE ( ws caseAlternatives )+ ) | ( CASE expression ( ws caseAlternatives )+ ) ) ( ws ELSE ws expression )? ws END ;
 */
	(('CASE' (caseAlternatives+=CaseAlternatives)+) | ('CASE' caseExpression=Expression
	(caseAlternatives+=CaseAlternatives)+)) ('ELSE' elseExpression=Expression)? 'END';

CaseAlternatives:
/*
 * caseAlternatives : WHEN ws expression ws THEN ws expression ;
 */
	'WHEN' when=Expression 'THEN' then=Expression;

VariableDeclaration returns VariableDeclaration:
/*
 * variable : symbolicName ;
 */
	{VariableDeclaration} name=SYMBOLIC_NAME_X;

MapLiteral:
/*
 * mapLiteral : '{' ws ( propertyKeyName ws ':' ws expression ws ( ',' ws propertyKeyName ws ':' ws expression ws )* )? '}' ;
 * 
 * Comment: For simplicity we split up the antlr clause in 'MapLiteral' and 'MapLiteralEntry'
 */
	{MapLiteral} '{' (entries+=MapLiteralEntry (',' entries+=MapLiteralEntry)*)? '}';

MapLiteralEntry:
	key=PropertyKeyName ':' value=Expression;

LegacyParameter:
/*
 * legacyParameter : '{' ws ( symbolicName | DecimalInteger ) ws '}' ;
 * 
 * Comment: Format of DecimalInteger is checked via 
 * org.slizaa.neo4j.opencypher.validation.OpenCypherValidator.checkLegacyParameterFormat(LegacyParameter)
 */
	'{' parameter=(SYMBOLIC_NAME_X | Number) '}';

Parameter:
/*
 * parameter : '$' ( symbolicName | DecimalInteger ) ;
 * 
 * Comment: Format of DecimalInteger is checked via 
 * org.slizaa.neo4j.opencypher.validation.OpenCypherValidator.checkParameterFormat(Parameter)
 */
	'$' parameter=(SYMBOLIC_NAME_X | Number);

PropertyExpression:
/*
 * propertyExpression : atom ( ws propertyLookup )+ ;
 */
	Atom (propertyLookups+=PropertyLookup)+;

PropertyKeyName:
/*
 * propertyKeyName : symbolicName ;
 */
	SYMBOLIC_NAME_X;

LeftArrowHead:
/*
 * Comment: reduced character set
 */
	'<';

RightArrowHead:
/*
 * Comment: reduced character set
 */
	'>';

Dash:
/*
 * Comment: reduced character set
 */
	'-';

DecimalInteger:
/*
 * Comment: Format of DecimalInteger is checked via 
 * org.slizaa.neo4j.opencypher.validation.OpenCypherValidator.checkDecimalIntegerFormat(DecimalInteger)
 */
	{DecimalInteger} value=Number;

Number hidden():
	HEX | (INT | DECIMAL) ('.' (INT | DECIMAL))?;

SYMBOLIC_NAME_X:
/*
 * symbolicNameString : UnescapedSymbolicNameString
 *                  | EscapedSymbolicNameString
 *                  | CYPHER
 *                  | EXPLAIN
 *                  | PROFILE
 *                  | USING
 *                  | PERIODIC
 *                  | COMMIT
 *                  | UNION
 *                  | ALL
 *                  | CREATE
 *                  | INDEX
 *                  | ON
 *                  | DROP
 *                  | CONSTRAINT
 *                  | ASSERT
 *                  | IS
 *                  | UNIQUE
 *                  | EXISTS
 *                  | LOAD
 *                  | CSV
 *                  | WITH
 *                  | HEADERS
 *                  | FROM
 *                  | AS
 *                  | FIELDTERMINATOR
 *                  | OPTIONAL
 *                  | MATCH
 *                  | UNWIND
 *                  | MERGE
 *                  | SET
 *                  | DELETE
 *                  | DETACH
 *                  | REMOVE
 *                  | FOREACH
 *                  | IN
 *                  | DISTINCT
 *                  | RETURN
 *                  | ORDER
 *                  | BY
 *                  | L_SKIP
 *                  | LIMIT
 *                  | DESCENDING
 *                  | DESC
 *                  | ASCENDING
 *                  | ASC
 *                  | JOIN
 *                  | SCAN
 *                  | START
 *                  | NODE
 *                  | RELATIONSHIP
 *                  | REL
 *                  | WHERE
 *                  | SHORTESTPATH
 *                  | ALLSHORTESTPATHS
 *                  | OR
 *                  | XOR
 *                  | AND
 *                  | NOT
 *                  | STARTS
 *                  | ENDS
 *                  | CONTAINS
 *                  | NULL
 *                  | TRUE
 *                  | FALSE
 *                  | COUNT
 *                  | FILTER
 *                  | EXTRACT
 *                  | ANY
 *                  | NONE
 *                  | SINGLE
 *                  | REDUCE
 *                  | CASE
 *                  | ELSE
 *                  | END
 *                  | WHEN
 *                  | THEN
 *                  | L_0X
 *                   ;
 */
	ID | 'CYPHER' | 'EXPLAIN' | 'PROFILE' | 'USING' | 'PERIODIC' | 'COMMIT' | 'UNION' | 'ALL' | 'CREATE' | 'INDEX' | 'ON'
	| 'DROP' | 'CONSTRAINT' | 'ASSERT' | 'IS' | 'UNIQUE' | 'EXISTS' | 'LOAD' | 'CSV' | 'WITH' | 'HEADERS' | 'FROM' | 'AS'
	| 'FIELDTERMINATOR' | 'OPTIONAL' | 'MATCH' | 'UNWIND' | 'MERGE' | 'SET' | 'DELETE' | 'DETACH' | 'REMOVE' | 'FOREACH'
	| 'IN' | 'DISTINCT' | 'RETURN' | 'ORDER' | 'BY' | 'SKIP' | 'LIMIT' | 'DESCENDING' | 'DESC' | 'ASCENDING' | 'ASC' |
	'JOIN' | 'SCAN' | 'START' | 'NODE' | 'RELATIONSHIP' | 'REL' | 'WHERE' | 'SHORTESTPATH' | 'ALLSHORTESTPATHS' | 'OR' |
	'XOR' | 'AND' | 'NOT' | 'STARTS' | 'ENDS' | 'CONTAINS' | 'NULL' | 'TRUE' | 'FALSE' | 'COUNT' | 'FILTER' | 'EXTRACT' |
	'ANY' | 'NONE' | 'SINGLE' | 'REDUCE' | 'CASE' | 'ELSE' | 'END' | 'WHEN' | 'THEN';

terminal ID:
/*
 * Comment: reduced character set
 */
	('a'..'z' | 'A'..'Z' | '_') ('a'..'z' | 'A'..'Z' | '_' | '0'..'9')* | ('`'->'`');

terminal ML_COMMENT:
	'/*'->'*/';

terminal SL_COMMENT:
	'//' !('\n' | '\r')* ('\r'? '\n')?;

terminal WS:
	(' ' | '\t' | '\r' | '\n')+;

terminal STRING_LITERAL:
	'"' ('\\' . /* 'b'|'t'|'n'|'f'|'r'|'u'|'"'|"'"|'\\' */ | !('\\' | '"'))* '"' | "'" ('\\' .
	/* 'b'|'t'|'n'|'f'|'r'|'u'|'"'|"'"|'\\' */ | !('\\' | "'"))* "'";

terminal HEX:
	('0x' | '0X') ('0'..'9' | 'A'..'F')+;

terminal INT returns ecore::EInt:
	'0'..'9' ('0'..'9')*;

terminal DECIMAL:
	INT (('e') ('+' | '-')? INT)?;
